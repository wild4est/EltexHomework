#include <stdio.h>

/*!
 * \breif Функция, заменяющая третий байт в переменной типа int
 * \param int num - число, в котором будут изменять третий байт
 * \param unsigned char num_replaced - число, в которым будут заменять третий байт
 * \detail Замена происходит через указатель. Принятое число num переводится в указатель
 * на тип unsigned char. Таким образом 
 */
int ReplaceThirdByte(int num, unsigned char num_replaced);

/*!
 * \brief Функция, выполняющая второй пункт домашнего задания
 */
void Result12(void);

/*!
 * \brief Функция, которая заполняет массив числами понарастанию, начиная с единицы
 * \param int* array - указатель на начало заполняемого массива
 * \param int n - размер массива
 */
void FillArray(int* array, int n);

/*!
 * \brief Функция, которая выводит целочисленный массив поэлементно
 * \param int* array - указатель на начало массива
 * \param int n - размер массива
 */
void PrintArrayInt(int* array, int n);

/*!
 * \brief Функция, которая выводит строку
 * \param const char* array - указатель на начало строки
 * \param int n - колличество символов в строке
 */
void PrintArrayChar(const char* array, int n);

/*!
 * \brief Функция, возвращающая колличество символов в строке
 * \param const char* str - указатель на начало строки
 * \return колличество символов в строке
 */
int GetStringSize(const char* str);

/*!
 * \breif Функция, реализующая Bitap алгоритм для поиска подстроки
 * \param const char* text - строка, в которой ищется подстрока
 * \param const char* pattern - подстрока
 * \param int text_size - размер строки
 * \param int pattern_size - размер подстроки
 * \return Если подстрока найдена вернётся указатель на начало подстроки в строке, в ином случае вернутся NULL.
 * \detail Суть Bitap алгоритма сводится к составлению масок для всех символов находящихся в подстроке. Такая маска
 * должна отражать положение текущего символа в подстроке (1 - символа нет, 0 - символ есть). Затем алгоритм в цикле 
 * проходится по основной строке, берёт маску текущей буквы и накладывает её на некий битовый массив, который в начале
 * представлет собой набор единиц с *ведущим нулём* в начале. Дело в том, что если в процессе перебора будут попадаться
 * буквы из подстроки в нужном порядке, то во время наложения масок в битовом массиве тот самый *ведущий ноль* будет
 * сдвигаться налево. И в тот момент, когда он дойдёт до конца подстроки алгоритм считает, что подстрока найдена.
 * Тогда алгоритм откатит указатель на то место, где начинается подстрока и вернёт полученное значение.
 * Если же во время перебора алгоритм дошёл до конца строки, но так и не довёл *ведущий ноль* до конца, вернётся NULL.
 */
const char* BitapAlgorithm(const char* text, const char* pattern, int text_size, int pattern_size);
